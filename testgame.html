<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Tetris (Bouncing Dog Face BG) - HTML/CSS/JS</title>
  <style>
    :root{
      --bg:#05060a;
      --text:#eaf2ff;
      --muted:#8aa0c9;

      --neon1:#7c5cff;
      --neon2:#2dd4bf;
      --neon3:#ff4dff;
      --neon4:#00d4ff;

      --glass: rgba(255,255,255,.06);
      --glass2: rgba(255,255,255,.03);
      --stroke: rgba(255,255,255,.10);
    }

    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      color: var(--text);
      background: radial-gradient(900px 520px at 20% 20%, rgba(124,92,255,.18), transparent 60%),
                  radial-gradient(900px 520px at 80% 70%, rgba(45,212,191,.14), transparent 60%),
                  radial-gradient(700px 420px at 65% 20%, rgba(255,77,255,.10), transparent 60%),
                  var(--bg);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      overflow:hidden;
    }

    body::before,
    body::after{
      content:"";
      position:fixed;
      inset:-30vh -30vw;
      pointer-events:none;
      background:
        radial-gradient(1px 1px at 12% 18%, rgba(255,255,255,.55), transparent 55%),
        radial-gradient(1px 1px at 42% 28%, rgba(45,212,191,.65), transparent 55%),
        radial-gradient(1px 1px at 72% 16%, rgba(124,92,255,.65), transparent 55%),
        radial-gradient(1px 1px at 84% 46%, rgba(255,77,255,.55), transparent 55%),
        radial-gradient(1px 1px at 18% 62%, rgba(0,212,255,.55), transparent 55%),
        radial-gradient(1px 1px at 52% 78%, rgba(255,255,255,.45), transparent 55%),
        radial-gradient(1px 1px at 90% 86%, rgba(45,212,191,.55), transparent 55%);
      opacity:.45;
      filter: blur(.2px);
      animation: drift 12s linear infinite;
    }
    body::after{
      opacity:.30;
      transform: scale(1.15);
      animation-duration: 18s;
    }
    @keyframes drift{
      from{ transform: translate3d(0,0,0) scale(1); }
      to{ transform: translate3d(-3vw,2vh,0) scale(1.02); }
    }

    .app{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:18px;
      align-items:start;
      position:relative;
      z-index:1;
    }
    @media (max-width: 900px){
      .app{grid-template-columns: 1fr;}
    }

    .panel{
      background: linear-gradient(180deg, var(--glass), var(--glass2));
      border-radius: 18px;
      padding: 18px;
      border: 1px solid var(--stroke);
      box-shadow:
        0 18px 70px rgba(0,0,0,.55),
        0 0 40px rgba(124,92,255,.12);
      backdrop-filter: blur(10px);
    }

    .neonFrame{ position:relative; border-radius: 18px; }
    .neonFrame::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 20px;
      background: conic-gradient(
        from 180deg,
        rgba(124,92,255,.75),
        rgba(45,212,191,.75),
        rgba(255,77,255,.75),
        rgba(0,212,255,.75),
        rgba(124,92,255,.75)
      );
      filter: blur(10px);
      opacity:.55;
      animation: hue 8s linear infinite;
      pointer-events:none;
    }
    .neonFrame::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      pointer-events:none;
    }
    @keyframes hue{ from{ transform: rotate(0deg); } to{ transform: rotate(360deg); } }

    h1{
      font-size: 20px;
      margin: 0 0 12px 0;
      letter-spacing: .2px;
      text-shadow: 0 0 10px rgba(124,92,255,.35);
    }

    .row{display:flex; align-items:center; justify-content:space-between; gap:10px; margin:10px 0;}

    .metric{
      background: rgba(0,0,0,.20);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px 12px;
      display:flex;
      flex-direction:column;
      gap:4px;
      width: 100%;
      box-shadow: 0 0 18px rgba(45,212,191,.10);
    }
    .metric .label{color: var(--muted); font-size: 12px;}
    .metric .value{font-size: 18px; font-weight: 800; letter-spacing:.3px;}

    .canvasWrap{display:flex; justify-content:center; align-items:center; padding: 8px;}

    canvas{
      background: rgba(0,0,0,.55);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      image-rendering: pixelated;
      box-shadow:
        0 0 22px rgba(124,92,255,.18),
        0 0 34px rgba(45,212,191,.10);
      width: min(420px, 100%);
      height: auto;
    }

    .previewBox{
      position:relative;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:10px;
      border-radius: 16px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow:
        0 0 18px rgba(255,77,255,.12),
        0 0 26px rgba(0,212,255,.10);
    }
    .previewTitle{color: var(--muted); font-size:12px; letter-spacing:.2px;}

    #next{
      width: 132px;
      height: 132px;
      background: rgba(0,0,0,.55);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      image-rendering: pixelated;
      box-shadow:
        0 0 18px rgba(0,212,255,.16),
        0 0 30px rgba(255,77,255,.10);
    }

    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px;}

    button{
      cursor:pointer;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 800;
      transition: transform .05s ease, filter .15s ease, border-color .15s ease;
      user-select:none;
      box-shadow: 0 0 18px rgba(124,92,255,.12);
    }
    button:hover{ filter: brightness(1.1); border-color: rgba(124,92,255,.45); }
    button:active{ transform: translateY(1px); }

    .primary{
      border-color: rgba(45,212,191,.55);
      box-shadow:
        0 0 18px rgba(45,212,191,.18),
        0 0 30px rgba(0,212,255,.12);
    }

    .hint{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      margin-top: 14px;
      border-top: 1px dashed rgba(255,255,255,.14);
      padding-top: 12px;
    }

    .overlay{ position: relative; }
    .banner{
      position:absolute;
      inset: 18px;
      display:none;
      align-items:center;
      justify-content:center;
      text-align:center;
      background: rgba(5,6,10,.78);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 18px;
      box-shadow:
        0 0 35px rgba(124,92,255,.18),
        0 0 55px rgba(45,212,191,.10);
    }
    .banner.show{display:flex;}
    .banner h2{
      margin:0 0 8px 0;
      font-size: 22px;
      text-shadow:
        0 0 12px rgba(124,92,255,.35),
        0 0 22px rgba(255,77,255,.20);
    }
    .banner p{margin:0; color: var(--muted);}

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      color: var(--text);
      display:inline-block;
      margin: 0 2px;
      box-shadow: 0 0 14px rgba(0,212,255,.08);
    }

    .flicker{ animation: flicker 6.5s infinite; }
    @keyframes flicker{
      0%, 92%, 100%{ opacity:1; }
      94%{ opacity:.88; }
      96%{ opacity:1; }
      98%{ opacity:.92; }
    }

    /* ê°•ì•„ì§€ ì´ë¯¸ì§€ ë¡œë”© ì•ˆë‚´(ì„ íƒ) */
    .note{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }
    .note code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      padding: 1px 6px;
      border-radius: 8px;
      color: var(--text);
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="neonFrame">
      <div class="panel stage overlay flicker">
        <div class="canvasWrap">
          <canvas id="game" width="240" height="480" aria-label="í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„" role="img"></canvas>
        </div>
        <div id="banner" class="banner" aria-live="polite">
          <div>
            <h2 id="bannerTitle">ê²Œì„ ì˜¤ë²„</h2>
            <p id="bannerDesc">ì•„ë˜ <b>ë‹¤ì‹œ í•˜ê¸°</b> ë²„íŠ¼ìœ¼ë¡œ ì¦‰ì‹œ ì¬ì‹œì‘í•  ìˆ˜ ìˆì–´.</p>
          </div>
        </div>
      </div>
    </div>

    <aside class="panel hud neonFrame" style="padding:18px;">
      <h1 class="flicker">NEON TETRIS</h1>

      <div class="row">
        <div class="metric">
          <div class="label">ì ìˆ˜</div>
          <div class="value" id="score">0</div>
        </div>
        <div class="metric">
          <div class="label">ë ˆë²¨</div>
          <div class="value" id="level">1</div>
        </div>
      </div>

      <div class="row">
        <div class="metric">
          <div class="label">ì§€ìš´ ì¤„</div>
          <div class="value" id="lines">0</div>
        </div>
      </div>

      <div class="row" style="gap:12px; align-items:stretch;">
        <div class="previewBox">
          <div class="previewTitle">ë‹¤ìŒ ë¸”ë¡ ë¯¸ë¦¬ë³´ê¸°</div>
          <canvas id="next" width="132" height="132"></canvas>
        </div>

        <div class="metric" style="min-height: 164px; justify-content:center;">
          <div class="label">ìƒíƒœ</div>
          <div class="value" id="status">ì§„í–‰ ì¤‘</div>
        </div>
      </div>

      <div class="btns">
        <button id="restart" class="primary" type="button">ë‹¤ì‹œ í•˜ê¸°</button>
        <button id="pause" type="button">ì¼ì‹œì •ì§€</button>
        <button id="hardDrop" type="button">í•˜ë“œ ë“œë¡­</button>
      </div>

      <div class="hint">
        <div style="margin-bottom:8px;"><b>ì¡°ì‘</b></div>
        <div>ì´ë™: <span class="kbd">â†</span><span class="kbd">â†’</span></div>
        <div>ë‚´ë¦¬ê¸°: <span class="kbd">â†“</span></div>
        <div>íšŒì „: <span class="kbd">â†‘</span></div>
        <div>í•˜ë“œ ë“œë¡­: <span class="kbd">Space</span></div>
        <div>ì¼ì‹œì •ì§€: <span class="kbd">P</span></div>
      </div>

      <div class="note">
        <b>ê°•ì•„ì§€ ë°°ê²½ ì´ë¯¸ì§€</b>: ì´ HTMLê³¼ ê°™ì€ í´ë”ì— ê°•ì•„ì§€ ì‚¬ì§„ì„ <code>dog.png</code>ë¡œ ì €ì¥í•˜ë©´,
        ê°•ì•„ì§€ ì–¼êµ´ì´ ë°˜íˆ¬ëª…ìœ¼ë¡œ ë²½ì—ì„œ ë²½ìœ¼ë¡œ ì²œì²œíˆ íŠ•ê²¨ ë‹¤ë…€.
      </div>
    </aside>
  </div>

  <script>
    (() => {
      const COLS = 10;
      const ROWS = 20;
      const BLOCK = 24;

      const COLORS = {
        0: "rgba(0,0,0,0)",
        I: "#00d4ff",
        O: "#ffe66b",
        T: "#7c5cff",
        S: "#2dd4bf",
        Z: "#ff4dff",
        J: "#60a5fa",
        L: "#ff8a3d",
        ghost: "rgba(255,255,255,.12)",
        grid: "rgba(255,255,255,.08)",
      };

      // ë™ë¬¼ ì´ëª¨í‹°ì½˜(ì–¼êµ´ ìœ„ì£¼)
      const EMOJI = {
        O: "ğŸ¥",
        S: "ğŸ", // ì–¼êµ´ ì „ìš© ì´ëª¨í‹°ì½˜ì€ ì—†ì–´ ê°€ì¥ ê°€ê¹Œìš´ ë±€ ì‚¬ìš©
        J: "ğŸ¦",
        L: "ğŸ¹",
        T: "ğŸ±",
        Z: "ğŸ·",
        I: "ğŸ¸",
      };

      const LINE_SCORES = [0, 100, 300, 500, 800];

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const nextCanvas = document.getElementById('next');
      const nctx = nextCanvas.getContext('2d');

      const scoreEl = document.getElementById('score');
      const levelEl = document.getElementById('level');
      const linesEl = document.getElementById('lines');
      const statusEl = document.getElementById('status');

      const banner = document.getElementById('banner');
      const bannerTitle = document.getElementById('bannerTitle');
      const bannerDesc = document.getElementById('bannerDesc');

      const restartBtn = document.getElementById('restart');
      const pauseBtn = document.getElementById('pause');
      const hardDropBtn = document.getElementById('hardDrop');

      const SHAPES = {
        I: [
          [0,0,0,0],
          [1,1,1,1],
          [0,0,0,0],
          [0,0,0,0],
        ],
        O: [
          [1,1],
          [1,1],
        ],
        T: [
          [0,1,0],
          [1,1,1],
          [0,0,0],
        ],
        S: [
          [0,1,1],
          [1,1,0],
          [0,0,0],
        ],
        Z: [
          [1,1,0],
          [0,1,1],
          [0,0,0],
        ],
        J: [
          [1,0,0],
          [1,1,1],
          [0,0,0],
        ],
        L: [
          [0,0,1],
          [1,1,1],
          [0,0,0],
        ],
      };
      const TYPES = Object.keys(SHAPES);

      function cloneMatrix(m){ return m.map(r => r.slice()); }

      function rotate(matrix){
        const N = matrix.length;
        const M = matrix[0].length;
        const res = Array.from({length: M}, () => Array(N).fill(0));
        for(let y=0; y<N; y++){
          for(let x=0; x<M; x++){
            res[x][N - 1 - y] = matrix[y][x];
          }
        }
        return res;
      }

      function randBag(){
        const bag = TYPES.slice();
        for(let i=bag.length-1; i>0; i--){
          const j = (Math.random() * (i+1)) | 0;
          [bag[i], bag[j]] = [bag[j], bag[i]];
        }
        return bag;
      }

      let board;
      let current;
      let nextType;
      let bag = [];

      let score = 0;
      let lines = 0;
      let level = 1;

      let dropCounter = 0;
      let dropInterval = 780;
      let lastTime = 0;

      let isPaused = false;
      let isGameOver = false;

      // =============================
      // âœ… ê°•ì•„ì§€ ì–¼êµ´ ë°˜íˆ¬ëª… ë°”ìš´ìŠ¤ ë°°ê²½
      // =============================
      const dog = {
        img: new Image(),
        ready: false,
        sprite: null,        // ì–¼êµ´ë§Œ ì˜ë¼ë‚¸ ì›í˜• ìŠ¤í”„ë¼ì´íŠ¸(offscreen canvas)
        spriteSize: 96,
        x: 40,
        y: 60,
        vx: 18,             // px/sec (ì²œì²œíˆ)
        vy: 14,
        alpha: 0.18,
      };

      // ì´ HTMLê³¼ ê°™ì€ í´ë”ì— dog.pngë¡œ ë„£ìœ¼ë©´ ìë™ ë¡œë“œ
      dog.img.src = 'dog.png';
      dog.img.onload = () => {
        dog.ready = true;
        dog.sprite = buildDogFaceSprite(dog.img, dog.spriteSize);
      };
      dog.img.onerror = () => {
        // ì´ë¯¸ì§€ ì—†ìœ¼ë©´ ì¡°ìš©íˆ íŒ¨ìŠ¤
        dog.ready = false;
      };

      function buildDogFaceSprite(img, size){
        // ì–¼êµ´ ì˜ì—­ì€ ìë™ ì¶”ì •(ëŒ€ëµ ì¤‘ì•™/ìƒë‹¨)
        // í•„ìš”í•˜ë©´ ì•„ë˜ crop ë¹„ìœ¨ë§Œ ì¡°ì •í•˜ë©´ ë¨.
        const w = img.naturalWidth || img.width;
        const h = img.naturalHeight || img.height;

        // ì–¼êµ´ì´ ì¤‘ì•™ì— ìˆëŠ” ì‚¬ì§„ì„ ê¸°ì¤€ìœ¼ë¡œ: ê°€ë¡œ 46% ì •ë„ë¥¼ ì–¼êµ´ë¡œ ê°€ì •
        const side = Math.floor(Math.min(w, h) * 0.46);
        const sx = Math.floor(w * 0.50 - side/2);
        const sy = Math.floor(h * 0.42 - side/2);

        const oc = document.createElement('canvas');
        oc.width = size;
        oc.height = size;
        const octx = oc.getContext('2d');

        // ì›í˜• ë§ˆìŠ¤í¬
        octx.save();
        octx.beginPath();
        octx.arc(size/2, size/2, size/2 - 1, 0, Math.PI*2);
        octx.closePath();
        octx.clip();

        octx.imageSmoothingEnabled = true;
        octx.drawImage(img, sx, sy, side, side, 0, 0, size, size);
        octx.restore();

        // ì€ì€í•œ í…Œë‘ë¦¬/ê¸€ë¡œìš°
        octx.save();
        octx.strokeStyle = 'rgba(255,255,255,.22)';
        octx.lineWidth = 2;
        octx.shadowBlur = 14;
        octx.shadowColor = 'rgba(0,212,255,.25)';
        octx.beginPath();
        octx.arc(size/2, size/2, size/2 - 2, 0, Math.PI*2);
        octx.stroke();
        octx.restore();

        return oc;
      }

      function updateDogBG(dt){
        if(!dog.ready || !dog.sprite) return;
        // ì¼ì‹œì •ì§€/ê²Œì„ì˜¤ë²„ì—¬ë„ ë°°ê²½ì€ "ì²œì²œíˆ" ê³„ì† ì›€ì§ì´ê²Œ(ìš”ì²­ ëŠë‚Œ ìœ ì§€)
        const speedScale = 1.0;
        dog.x += dog.vx * dt * speedScale;
        dog.y += dog.vy * dt * speedScale;

        const pad = 6;
        const s = dog.spriteSize;
        const maxX = canvas.width - s - pad;
        const maxY = canvas.height - s - pad;

        if(dog.x < pad){ dog.x = pad; dog.vx = Math.abs(dog.vx); }
        if(dog.x > maxX){ dog.x = maxX; dog.vx = -Math.abs(dog.vx); }
        if(dog.y < pad){ dog.y = pad; dog.vy = Math.abs(dog.vy); }
        if(dog.y > maxY){ dog.y = maxY; dog.vy = -Math.abs(dog.vy); }
      }

      function drawDogBG(){
        if(!dog.ready || !dog.sprite) return;
        ctx.save();
        ctx.globalAlpha = dog.alpha;
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(dog.sprite, dog.x, dog.y);
        ctx.restore();
      }

      // ====== ê²Œì„ ì´ˆê¸°í™” ======
      function emptyBoard(){
        return Array.from({length: ROWS}, () => Array(COLS).fill(0));
      }

      function getTypeFromBag(){
        if(bag.length === 0) bag = randBag();
        return bag.pop();
      }

      function newPiece(type){
        const shape = cloneMatrix(SHAPES[type]);
        const x = ((COLS / 2) | 0) - ((shape[0].length / 2) | 0);
        const y = -1;
        return { type, matrix: shape, x, y };
      }

      function resetGame(){
        board = emptyBoard();
        score = 0;
        lines = 0;
        level = 1;
        dropInterval = 780;
        dropCounter = 0;
        lastTime = 0;

        isPaused = false;
        isGameOver = false;

        bag = randBag();
        current = newPiece(getTypeFromBag());
        nextType = getTypeFromBag();

        hideBanner();
        setStatus("ì§„í–‰ ì¤‘");
        pauseBtn.textContent = "ì¼ì‹œì •ì§€";
        syncUI();
        draw();
      }

      function setStatus(text){ statusEl.textContent = text; }

      function syncUI(){
        scoreEl.textContent = String(score);
        linesEl.textContent = String(lines);
        levelEl.textContent = String(level);
      }

      // ====== ì¶©ëŒ/ë³‘í•©/ì‚­ì œ ======
      function collide(b, piece){
        const m = piece.matrix;
        for(let y=0; y<m.length; y++){
          for(let x=0; x<m[y].length; x++){
            if(m[y][x] === 0) continue;
            const bx = piece.x + x;
            const by = piece.y + y;
            if(bx < 0 || bx >= COLS || by >= ROWS) return true;
            if(by >= 0 && b[by][bx] !== 0) return true;
          }
        }
        return false;
      }

      function merge(b, piece){
        const m = piece.matrix;
        for(let y=0; y<m.length; y++){
          for(let x=0; x<m[y].length; x++){
            if(m[y][x] === 0) continue;
            const bx = piece.x + x;
            const by = piece.y + y;
            if(by >= 0) b[by][bx] = piece.type;
          }
        }
      }

      function sweepLines(){
        let cleared = 0;
        outer:
        for(let y=ROWS-1; y>=0; y--){
          for(let x=0; x<COLS; x++){
            if(board[y][x] === 0) continue outer;
          }
          const row = board.splice(y, 1)[0];
          row.fill(0);
          board.unshift(row);
          cleared++;
          y++;
        }
        if(cleared > 0){
          lines += cleared;
          score += LINE_SCORES[cleared] * level;

          const newLevel = 1 + ((lines / 10) | 0);
          if(newLevel !== level){
            level = newLevel;
            dropInterval = Math.max(90, 780 - (level - 1) * 60);
          }
        }
      }

      function getGhost(piece){
        const ghost = { ...piece, matrix: piece.matrix, x: piece.x, y: piece.y };
        while(!collide(board, {...ghost, y: ghost.y + 1})) ghost.y++;
        return ghost;
      }

      // ====== ì¡°ì‘ ======
      function move(dx){
        if(isPaused || isGameOver) return;
        const test = { ...current, x: current.x + dx };
        if(!collide(board, test)) current.x += dx;
      }

      function softDrop(){
        if(isPaused || isGameOver) return;
        const test = { ...current, y: current.y + 1 };
        if(!collide(board, test)){
          current.y++;
          score += 1;
          return true;
        }
        lockPiece();
        return false;
      }

      function hardDrop(){
        if(isPaused || isGameOver) return;
        const ghost = getGhost(current);
        const dist = ghost.y - current.y;
        current.y = ghost.y;
        score += Math.max(0, dist) * 2;
        lockPiece();
      }

      function rotateCurrent(){
        if(isPaused || isGameOver) return;
        const rotated = rotate(current.matrix);
        const test = { ...current, matrix: rotated };
        const kicks = [0, -1, 1, -2, 2];
        for(const k of kicks){
          const kicked = { ...test, x: test.x + k };
          if(!collide(board, kicked)){
            current.matrix = rotated;
            current.x += k;
            return;
          }
        }
      }

      function lockPiece(){
        merge(board, current);
        sweepLines();
        spawnNext();
        syncUI();
      }

      function spawnNext(){
        current = newPiece(nextType);
        nextType = getTypeFromBag();
        if(collide(board, current)){
          isGameOver = true;
          setStatus("ê²Œì„ ì˜¤ë²„");
          showBanner("ê²Œì„ ì˜¤ë²„", "ì•„ë˜ <b>ë‹¤ì‹œ í•˜ê¸°</b> ë²„íŠ¼ìœ¼ë¡œ ì¦‰ì‹œ ì¬ì‹œì‘í•  ìˆ˜ ìˆì–´.");
        }
      }

      function togglePause(){
        if(isGameOver) return;
        isPaused = !isPaused;
        setStatus(isPaused ? "ì¼ì‹œì •ì§€" : "ì§„í–‰ ì¤‘");
        pauseBtn.textContent = isPaused ? "ì¬ê°œ" : "ì¼ì‹œì •ì§€";
        if(isPaused) showBanner("ì¼ì‹œì •ì§€", "\"ì¼ì‹œì •ì§€\" ë²„íŠ¼ ë˜ëŠ” <b>P</b> í‚¤ë¡œ ì¬ê°œí•  ìˆ˜ ìˆì–´.");
        else hideBanner();
      }

      // ====== ë Œë” ======
      function clearCanvas(c, context){ context.clearRect(0,0,c.width,c.height); }

      function drawGrid(){
        ctx.save();
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 1;
        for(let x=0; x<=COLS; x++){
          ctx.beginPath();
          ctx.moveTo(x*BLOCK + 0.5, 0);
          ctx.lineTo(x*BLOCK + 0.5, ROWS*BLOCK);
          ctx.stroke();
        }
        for(let y=0; y<=ROWS; y++){
          ctx.beginPath();
          ctx.moveTo(0, y*BLOCK + 0.5);
          ctx.lineTo(COLS*BLOCK, y*BLOCK + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawCell(context, x, y, color, size, typeForEmoji){
        // ë„¤ì˜¨ ë°”íƒ•
        context.save();
        context.shadowBlur = 10;
        context.shadowColor = color;
        context.fillStyle = color;
        context.fillRect(x*size, y*size, size, size);
        context.restore();

        // í•˜ì´ë¼ì´íŠ¸/ìŒì˜
        context.fillStyle = "rgba(255,255,255,.10)";
        context.fillRect(x*size, y*size, size, size*0.16);
        context.fillStyle = "rgba(0,0,0,.22)";
        context.fillRect(x*size, y*size + size*0.82, size, size*0.18);

        context.strokeStyle = "rgba(255,255,255,.12)";
        context.lineWidth = 1;
        context.strokeRect(x*size + 0.5, y*size + 0.5, size-1, size-1);

        // ì´ëª¨í‹°ì½˜(ì–¼êµ´)
        const emoji = typeForEmoji ? EMOJI[typeForEmoji] : null;
        if(emoji){
          const cx = x*size + size/2;
          const cy = y*size + size/2 + 0.5;
          context.save();
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.font = `700 ${Math.floor(size * 0.72)}px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji`;
          context.shadowBlur = 12;
          context.shadowColor = color;
          context.fillText(emoji, cx, cy);
          context.restore();
        }
      }

      function drawBoard(){
        for(let y=0; y<ROWS; y++){
          for(let x=0; x<COLS; x++){
            const v = board[y][x];
            if(v !== 0) drawCell(ctx, x, y, COLORS[v], BLOCK, v);
          }
        }
      }

      function drawPiece(piece, context, size, offsetX=0, offsetY=0){
        const m = piece.matrix;
        for(let y=0; y<m.length; y++){
          for(let x=0; x<m[y].length; x++){
            if(m[y][x] === 0) continue;
            const px = (piece.x + x + offsetX);
            const py = (piece.y + y + offsetY);
            if(context === ctx && py < 0) continue;
            drawCell(context, px, py, COLORS[piece.type], size, piece.type);
          }
        }
      }

      function drawGhost(ghost){
        const m = ghost.matrix;
        for(let y=0; y<m.length; y++){
          for(let x=0; x<m[y].length; x++){
            if(m[y][x] === 0) continue;
            const px = ghost.x + x;
            const py = ghost.y + y;
            if(py < 0) continue;
            ctx.fillStyle = "rgba(255,255,255,.10)";
            ctx.fillRect(px*BLOCK, py*BLOCK, BLOCK, BLOCK);
            ctx.strokeStyle = "rgba(0,212,255,.18)";
            ctx.strokeRect(px*BLOCK + 0.5, py*BLOCK + 0.5, BLOCK-1, BLOCK-1);
          }
        }
      }

      function drawNext(){
        clearCanvas(nextCanvas, nctx);
        const type = nextType;
        const matrix = SHAPES[type];
        const size = 24;

        nctx.save();
        nctx.strokeStyle = "rgba(255,255,255,.08)";
        for(let i=0; i<=6; i++){
          nctx.beginPath();
          nctx.moveTo(i*size + 0.5, 0);
          nctx.lineTo(i*size + 0.5, 6*size);
          nctx.stroke();
          nctx.beginPath();
          nctx.moveTo(0, i*size + 0.5);
          nctx.lineTo(6*size, i*size + 0.5);
          nctx.stroke();
        }
        nctx.restore();

        const w = matrix[0].length;
        const h = matrix.length;
        const ox = ((6 - w) / 2);
        const oy = ((6 - h) / 2);

        for(let y=0; y<h; y++){
          for(let x=0; x<w; x++){
            if(!matrix[y][x]) continue;
            drawCell(nctx, x + ox, y + oy, COLORS[type], size, type);
          }
        }
      }

      function draw(){
        clearCanvas(canvas, ctx);

        // âœ… 1) ê°•ì•„ì§€ ì–¼êµ´ ë°°ê²½(ë°˜íˆ¬ëª…) ë¨¼ì €
        drawDogBG();

        // âœ… 2) ê²Œì„ ìš”ì†Œë“¤ ìœ„ì—
        drawGrid();
        drawBoard();
        if(!isGameOver){
          const ghost = getGhost(current);
          drawGhost(ghost);
        }
        drawPiece(current, ctx, BLOCK);
        drawNext();
      }

      // ====== ë£¨í”„ ======
      function update(time=0){
        const delta = time - lastTime;
        lastTime = time;

        const dt = Math.min(0.05, delta / 1000); // ì•ˆì •í™”(ìµœëŒ€ 50ms)
        updateDogBG(dt);

        if(!isPaused && !isGameOver){
          dropCounter += delta;
          if(dropCounter >= dropInterval){
            softDrop();
            dropCounter = 0;
          }
        }
        draw();
        requestAnimationFrame(update);
      }

      // ====== ë°°ë„ˆ ======
      function showBanner(title, desc){
        bannerTitle.textContent = title;
        bannerDesc.innerHTML = desc;
        banner.classList.add('show');
      }
      function hideBanner(){ banner.classList.remove('show'); }

      // ====== ì´ë²¤íŠ¸ ======
      document.addEventListener('keydown', (e) => {
        if(["ArrowLeft","ArrowRight","ArrowDown","ArrowUp"," "].includes(e.key)) e.preventDefault();

        if(e.key === 'p' || e.key === 'P') togglePause();
        if(isPaused || isGameOver) return;

        switch(e.key){
          case 'ArrowLeft': move(-1); break;
          case 'ArrowRight': move(1); break;
          case 'ArrowDown': softDrop(); dropCounter = 0; break;
          case 'ArrowUp': rotateCurrent(); break;
          case ' ': hardDrop(); dropCounter = 0; break;
        }
        syncUI();
      }, {passive:false});

      restartBtn.addEventListener('click', resetGame);
      pauseBtn.addEventListener('click', togglePause);
      hardDropBtn.addEventListener('click', () => { hardDrop(); syncUI(); });

      // ì‹œì‘
      resetGame();
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
